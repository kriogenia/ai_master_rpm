\documentclass[onecolumn]{IEEEtran}

\usepackage{algorithm,algpseudocode}
\usepackage{amsmath}
\usepackage{authblk}
\usepackage[utf8]{inputenc}
\usepackage{nameref}
\usepackage{graphicx}
% \graphicspath{ {images/} }

% metadata
\author{Ricardo Soto Est√©vez}
\affil{Menendez Pelayo International University}
\date{\today}
\title{Practical study of basic Genetic Algorithm over the p-Hub Median Problem}

% custom macros
\newcommand{\ip}{\emph{p}} % todo remove
\newcommand{\wij}{\emph{W\textsubscript{ij}}}
\def\code#1{\texttt{#1}}
\def\point#1#2{\emph{#1\textsubscript{#2}}}

\begin{document}

\maketitle

\begin{abstract} \noindent {
This article addresses the single allocation p-hub median problem by applying a genetic algorithm (GA)
to optimize hub placements. It details the fitness function for evaluating candidate solutions and describes
the genetic operators used to generate new populations. Performance benchmarks across various problem sizes
are presented to compare implementations and identify the most effective configurations.
} \end{abstract}

\begin{IEEEkeywords}
Hub location, genetic algorithms, heuristic solution, metaheuristics, analysis 
\end{IEEEkeywords}

\input{sections/introduction.tex}
\input{sections/mathematical_formulation.tex}

\section{Genetic Algorithm}

Our implementation follows the basic schema of every GA\cite{Thede2004}. Creation and evaluation of an initial
population (\emph{P}), and improvement of that population until a termination condition is met. The population
refinement  is done via a \emph{selection} of two or more parents, generation of new childs from the
\emph{crossover} of these parents, application of a \emph{mutation} to diversify the population and a
evaluation of the childs to select and \emph{refine} the new population that will be used in the next
iteration of the loop.

% todo name the vars like population_size? <-- assign a greek letter and modify the population defininition

In order to improve the performance of the algorithm some domain-specific components were implemented,
mainly in the \nameref{ss:crossover} (\ref{ss:crossover}) 
and \nameref{ss:mutation} (\ref{ss:mutation}) steps. This 
section will offer a brief description of the implementation of every facet of the GA.

\subsection{Chromosome encoding\label{ss:chromosome}}

The chromosome encoding that we used in our individuals is an array \emph{S} of size \emph{n} where each
index would point to the randomly assigned hub of each node. On top of that, these individuals are built
with the necessary contracts to ensure that they always contain \emph{p} unique values stored in the chromosome,
that way we are ensuring that every chromosome is a valid solution with \emph{p} hubs.

\begin{equation}
  S = [1, 1, 5, 1, 5, 5, 9, 1, 5, 9 ],\quad p = 3 \label{eq:chromosome_example}
\end{equation}

An example of this chromosome to a problem of size \emph{n = 10} and \emph{p = 3} is the one shown
at (\ref{eq:chromosome_example}). In this example the node 1 is assigned to itself as indicated
by $S_{1}=1$, the node 2 is allocated also to node 1, the node 3 to another hub placed in 5 and so on.
See also that $U(S)=\{1,5,9\}$ fulfilling the $|U(S)|=3$ requirement to have $p=3$ hubs.

The generation of the initial population of individuals is random, selecting three different values from
${1,\dots,n}$ and randomly assigning them to the different hubs. To ensure that all three have at least
one assigned hub, these first random chromosome will always allocated each hub to itself (\ref{eq:autoalloc}).

\begin{equation}
  S_{i}=i, \forall i \in U(S) \label{eq:autoalloc}
\end{equation}

\subsection{Selection}

In the selection step the strategy used is the \emph{Binary Tournament}. We pick two random individuals from
the population and select the one with the higher fitness (alg. \ref{alg:select_parent}).
In case of equal fitness the first candidate gets the priority. Both random individuals can be the same,
in that case, that individual is ensured to be picked for the crossover step.

This is done twice to select a total of two parents.  Both selected parents can also be the same individual,
in that case the child generated will be a clone of the parent, but can still provide a better solution with
the mutation.

\begin{algorithm}[H]
\caption{Selection of one parent}
\label{alg:select_parent}
\begin{algorithmic}[1]
  \Require{$P = S_{1},\dots,S_{n}$}
  \Ensure{$parent \in P$}
  \Function{SelectParent}{$S[\;]$}
    \State $firstCandidate \gets randomNode(N)$
    \State $secondCandidate \gets randomNode(N)$
    \If {$firstCandidate \ge secondCandidate$}
      \State \Return {$firstCandidate$}
    \Else
      \State \Return {$secondCandidate$}
    \EndIf
  \EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Crossover\label{ss:crossover}}

\subsection{Mutation\label{ss:mutation}}

\subsection{Replacement}

\section{Computational results}

\section{Conclusion}

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
